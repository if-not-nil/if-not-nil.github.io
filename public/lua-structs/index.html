<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>making lua do what it shouldn&#39;t: typesafe structs | if err != nil</title>
  <link rel="canonical" href="http://localhost:1313/">
  <link rel='alternate' type='application/rss+xml' title="if err != nil RSS" href='/index.xml'>
  <link rel='stylesheet' type='text/css' href='/new.css'>
  
  <link rel="icon" href="/favicon.gif">
  <meta name="description" content="it shouldn&#39;t, but it should should, if that makes sense">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="index, follow">
  <meta charset="utf-8">
  <script>
    window.goatcounter = {
      path: location.pathname || '/',
    }
  </script>
  <script data-goatcounter="https://if-not-nil.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>

<body>
  <header>
  <h1>if err != nil</h1>

  <nav>
    <a href="http://localhost:1313//">home</a> /
    
    <a href="https://github.com/if-not-nil">github</a>
  </nav> 
  
  
  
  
  
  
</header>


  <main>
    
<article>
	<div class="nextprev">

  <span class="prevart">
    <a href="/no-the-moon/">
      <div>‚Üêprev<br />no, the moon</div>
    </a>
    </span>

  <span class="nextart"></span>

</div>

<style>
  .prevart,
  .nextart {
    display: inline-block;
    flex: 1 1 50%;
    max-width: 50%;
  }

  .prevart>a,
  .nextart>a {
    line-clamp: 3;
    text-decoration: none;
    font-size: small;
    height: calc(3 * 1.2em);
    background: var(--bg-2);

  }

  .nextart {
    text-align: end;
  }

  .nextprev {
    padding: 4px;
    display: flex;
    justify-content: space-between;
    height: calc(3 * 1.2em);
  }
</style>
<span class="articleheader">
		<h1>making lua do what it shouldn&#39;t: typesafe structs</h1>
		<p>it shouldn&#39;t, but it should should, if that makes sense<br />
		<span style="font-size:14px;"> December 13, 2025</span>
		</p>
		<hr>
	</span>
	<a href="https://github.com/if-not-nil/if-not-nil.github.io/issues/new">comments</a>
	<section><p>
<figure class="float-right"><img src="https://wiby.me/lh_c.gif"loading="lazy"
	><figcaption>i like this image</figcaption></figure>

<style>
figure.float-right {
  float: right;
  margin: 0.2em 0 0.8em 1em;
}

figure.float-left {
  float: left;
  margin: 0.2em 1em 0.8em 0;
}

figure.float-right,
figure.float-left {
  max-width: 260px;
}

figure img {
  width: 100%;
  height: auto;
}

figure figcaption {
  font-size: 0.85em;
  color: var(--text-darker);
}

</style>

lua is a horrible, horrible language. it has one data structure for everything - the table, which i&rsquo;ll be exploiting here.</p>
<!-- raw HTML omitted -->
<p>my main inspiration is the zig struct syntax<br>
or any struct syntax for that matter</p>
<p>which is just not that realistic to implement at all. but
i&rsquo;ll try hard enough to get motivated by the sunk cost fallacy</p>
<p>so for this one, i&rsquo;ll be implementing structs with no extra features</p>
<h3 id="toc">toc</h3>
<ul>
<li><a href="#structs">structs</a></li>
<li><a href="#you-cant-have-your-boat-and-eat-it-too">you can&rsquo;t have your boat and eat it too</a></li>
<li><a href="#how-it-ended-up-looking">how it ended up looking</a></li>
<li><a href="#plans">plans</a></li>
</ul>
<p>oh and also this makes mose sense in the context of me composing <a href="https://github.com/if-not-nil/soup">the soup files</a>.</p>
<p>i already made a result enum with Ok/Err</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> line_result <span style="color:#f92672">=</span> Result.Ok(<span style="color:#e6db74">&#34;soup.lua&#34;</span>)
</span></span><span style="display:flex;"><span>    :bind(<span style="color:#66d9ef">function</span>(filename)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">local</span> file, err <span style="color:#f92672">=</span> io.open(filename, <span style="color:#e6db74">&#34;r&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> file <span style="color:#66d9ef">then</span> <span style="color:#66d9ef">return</span> Result.Err(err) <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Result.Ok(file)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> line <span style="color:#f92672">=</span> line_result:unwrap()
</span></span></code></pre></div><p>and a match expression with guards which is supposed to be reused to account for lua being an interpreted language</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> m <span style="color:#f92672">=</span> soup.match()
</span></span><span style="display:flex;"><span>	:case(<span style="color:#ae81ff">6</span>, <span style="color:#e6db74">&#34;six&#34;</span>)
</span></span><span style="display:flex;"><span>	:case(<span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;seveen&#34;</span>)
</span></span><span style="display:flex;"><span>	:case(<span style="color:#66d9ef">function</span>(x) <span style="color:#66d9ef">return</span> x <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">end</span>, <span style="color:#e6db74">&#34;even&#34;</span>)
</span></span><span style="display:flex;"><span>	:case(<span style="color:#66d9ef">function</span>(x) <span style="color:#66d9ef">return</span> x <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">~=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">end</span>, <span style="color:#e6db74">&#34;odd&#34;</span>)
</span></span><span style="display:flex;"><span>	:otherwise(<span style="color:#e6db74">&#34;idk&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>soup.println({ m(<span style="color:#ae81ff">6</span>), m(<span style="color:#ae81ff">7</span>), m(<span style="color:#ae81ff">9</span>), m(<span style="color:#ae81ff">10</span>) })
</span></span></code></pre></div><p>so this was very much the natural next step</p>
<h1 id="structs">structs</h1>
<p>all tables in lua are always passed by reference, never by copy.</p>
<p>they are also, on accident, usually the biggest and the smallest data structures possible.</p>
<p>so this opens up this neat little trick:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> l <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> _ <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    print({})
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- table: ...50c0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- table: ...5100</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> _ <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    print(l)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- table: ...10c0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- table: ...10c0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>now this isn&rsquo;t some grand insane discovery, BUT it lets you do something that
most people don&rsquo;t think about when making tagged data structures in lua</p>
<p>usually, they are done like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> t <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;point&#34;</span>,
</span></span><span style="display:flex;"><span>    value <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>this is an very very sane approach, which is very readable and is very perfect in the context of a sane codebase</p>
<p>but it definitely is not a fun way to do things</p>
<p>so i settled on this syntax</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> Point <span style="color:#f92672">&lt;</span>const<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> struct { x <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;number&#34;</span>, y <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;number&#34;</span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> p1 <span style="color:#f92672">=</span> Point { <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span> } <span style="color:#75715e">-- for those unfamiliar with lua, parentheses are implicit here.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> p2 <span style="color:#f92672">=</span> Point { <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span> } <span style="color:#75715e">-- struct and point are called like functions (even though they&#39;re tables)</span>
</span></span></code></pre></div><p>and the resulting structs, which look like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>{Point, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>}
</span></span><span style="display:flex;"><span>{Point, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>}
</span></span></code></pre></div><p>if you try to instantiate a point of 2 and &ldquo;asdf&rdquo;, it&rsquo;s gonna give you an error,
which is where the safety comes in</p>
<p><strong>implementation details warning!!!!!</strong></p>
<h1 id="you-cant-have-your-boat-and-eat-it-too">you can&rsquo;t have your boat and eat it too</h1>
<blockquote>
<p>we&rsquo;re now at commit 2e5fa: <code>lua: structs work at a minimum-wage level</code>. it&rsquo;s not relevant for what i ended up with</p>
</blockquote>
<p>here, <code>point</code> is a struct which stores these tables</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> names, <span style="color:#75715e">-- struct names: x and y </span>
</span></span><span style="display:flex;"><span>      types, <span style="color:#75715e">-- types: number, number</span>
</span></span><span style="display:flex;"><span>      index  <span style="color:#75715e">-- indices: { x = 2, y = 1, }</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">=</span> {}, {}, {}
</span></span></code></pre></div><p>is the index table really that necessary? probably not. but the limitations forced me to make it because the order in which you loop over a map is random</p>
<p>so, putting all the sacrifices together lets me make a nice oneliner</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>__index <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(tbl, key) <span style="color:#66d9ef">return</span> key <span style="color:#f92672">and</span> tbl[self.index[key]] <span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>and now we can get <code>point.x</code> and <code>point.y</code>, which asks the underlying type to tell it where x and y are</p>
<p>so, how is it different from the sane way?</p>
<p>first of all, a constructor is made automatically. it checks all the types when creating a struct
and you don&rsquo;t have to add the <code>if type(tbl[1]) == &quot;string&quot;</code></p>
<p>structs can also be embedded inside each other</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> l <span style="color:#f92672">=</span> Line {
</span></span><span style="display:flex;"><span>    Point { <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">22</span> },
</span></span><span style="display:flex;"><span>    Point { <span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">44</span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(l[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> Line)
</span></span></code></pre></div><p>but what happens if you try to get <code>line.start.x</code>?</p>
<p>remember how the you can&rsquo;t index a map in the order you were given it?</p>
<p>i thought i solved it like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>table.sort(names) <span style="color:#75715e">-- alphabetical</span>
</span></span></code></pre></div><p>and though it was ugly, it worked. i did it and forgot i put it in there. a point&rsquo;s <code>x</code> variable was always first, and <code>y</code> was always second. it worked perfectly</p>
<p>but obviously that&rsquo;s just not a fix</p>
<p>and the worst thing about unfixable things, is that if you try to fix them, they won&rsquo;t be fixed. because they&rsquo;re unfixable.</p>
<p>so i had to rewrite it to be</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>Point <span style="color:#f92672">=</span> struct {
</span></span><span style="display:flex;"><span>    {<span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>}, {<span style="color:#e6db74">&#34;y&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which is ugly</p>
<p>but it&rsquo;s not like i cared about it looking nice too much or anything. i&rsquo;m not even mad rught now</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>Point <span style="color:#f92672">=</span> struct {
</span></span><span style="display:flex;"><span>    { <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span> },
</span></span><span style="display:flex;"><span>    { <span style="color:#e6db74">&#34;y&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Line <span style="color:#f92672">=</span> struct {
</span></span><span style="display:flex;"><span>    { <span style="color:#e6db74">&#34;start&#34;</span>, Point },
</span></span><span style="display:flex;"><span>    { <span style="color:#e6db74">&#34;end&#34;</span>,   Point }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>so we have this syntax now</p>
<p>but yeah, the implementation actually went down from about 32 lines to 20
(also it doesn&rsquo;t look stupid anymore)</p>
<p>and, since we won&rsquo;t have duck typing, i&rsquo;ll allow for single-field structs to be initialized with just <code>Email(&quot;asdf@yahoo.com&quot;)</code></p>
<h1 id="how-it-ended-up-looking">how it ended up looking</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#e6db74">&#34;welcome to the end of the page if you skimmed it&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Point <span style="color:#f92672">=</span> struct {
</span></span><span style="display:flex;"><span>    { <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span> },
</span></span><span style="display:flex;"><span>    { <span style="color:#e6db74">&#34;y&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> p1 <span style="color:#f92672">=</span> Point { <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">33</span> }
</span></span><span style="display:flex;"><span>assert(p1[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>assert(p1.type <span style="color:#f92672">==</span> Point)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Line <span style="color:#f92672">=</span> struct {
</span></span><span style="display:flex;"><span>    { <span style="color:#e6db74">&#34;start&#34;</span>, Point },
</span></span><span style="display:flex;"><span>    { <span style="color:#e6db74">&#34;end&#34;</span>,   Point }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> p2 <span style="color:#f92672">=</span> Point { <span style="color:#ae81ff">44</span>, <span style="color:#ae81ff">55</span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> l <span style="color:#f92672">=</span> Line { p1, p2 }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Email <span style="color:#f92672">=</span> struct { <span style="color:#e6db74">&#34;string&#34;</span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> email <span style="color:#f92672">=</span> Email(<span style="color:#e6db74">&#34;test@example.com&#34;</span>)
</span></span><span style="display:flex;"><span>assert(email[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;test@example.com&#34;</span>)
</span></span><span style="display:flex;"><span>assert(email <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;test@example.com&#34;</span>) <span style="color:#75715e">-- sugar in the __tostring metatable</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(l.type <span style="color:#f92672">==</span> Line)
</span></span></code></pre></div><p>but hold on</p>
<p>isn&rsquo;t the biggest argument against duck typing the email struct?

<figure class="float-right"><img src="cat-on-a-monitor.jpg"loading="lazy"
	><figcaption>this guy knows email</figcaption></figure>

<style>
figure.float-right {
  float: right;
  margin: 0.2em 0 0.8em 1em;
}

figure.float-left {
  float: left;
  margin: 0.2em 1em 0.8em 0;
}

figure.float-right,
figure.float-left {
  max-width: 260px;
}

figure img {
  width: 100%;
  height: auto;
}

figure figcaption {
  font-size: 0.85em;
  color: var(--text-darker);
}

</style>
</p>
<p>it&rsquo;s always a good idea to make invalid states unrepresentable. ideally, your pipeline would look like this:</p>
<!-- raw HTML omitted -->
<ul>
<li>|&gt; <code> local email = Email.try_parse(&quot;test@example.com&quot;):expect(&quot;invalid email&quot;)</code>
<ul>
<li>| that function ensures the user&rsquo;s email isn&rsquo;t &ldquo;asdf&rdquo;, <!-- raw HTML omitted -->, or on outlook</li>
<li>| it would return the email struct (wrapped in the <a href="https://github.com/if-not-nil/soup/tree/main/lua#a-result-structure-soupresult">Result struct from the soup files btw</a>)</li>
</ul>
</li>
<li>|&gt; pass it into <code>function(email) end</code> which checks the type inside of it (and actually throws this time)</li>
<li>if the soup dream lives on, it would also be done through pipe operators</li>
</ul>
<p>this is why methods are absolutely necessary for your code to be readable. and if you know what rust traits are, you probably know why i love them, too</p>
<p>so, that&rsquo;s what i&rsquo;ll be implementing next. thanks for coming to my ted talk!</p>
<p>dude also i randomly came across a comment on the internet of someone putting this blog among their two top favorite dev blogs it made me so happy that was the only reason i felt like writing about this one</p>
<h1 id="plans">plans</h1>
<ul>
<li><input disabled="" type="checkbox"> traits: implement them to look like a magic rust translator. some
easy ones which are already accessible thru metatables are:
<ul>
<li><input disabled="" type="checkbox"> <code>Grid:impl(Traits.debug(), function(self) end)</code> (you can now print() the grid and tostring() it)</li>
<li><input disabled="" type="checkbox"> <code>Email:impl(Traits.from(&quot;string&quot;), function(str) end)</code> (you can now <code>Email.from(&quot;asdf@yahoo.com&quot;)</code>)</li>
<li><input disabled="" type="checkbox"> <code>Point:impl(Traits.sum(Point), function(self, other) end)</code> (you can now grid1 + grid2)</li>
<li><input disabled="" type="checkbox"> <code>Grid:impl(Traits.drop(), function(self) end)</code> (this will run when it goes out of scope after <code>local grid &lt;close&gt; = Grid(...)</code>)</li>
<li><input disabled="" type="checkbox"> <code>Grid:impl(Traits.trash(), function(self) end)</code> (this will run on garbage collection)</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> methods: exactly how it looks in normal lua, but one function is shared for all objects so it just has to be better</li>
</ul>
</section>
	
</article>

  </main>

  <footer>
    <a href="http://localhost:1313/">http://localhost:1313/</a><br><br><a href="/index.xml"><img src="/rss.svg" style="max-height:1.5em" alt="RSS Feed"
        title="Subscribe via RSS for updates."></a>
  </footer>
</body>

</html>
